#### Hashtable、HashMap、TreeMap心得
三者均实现了Map接口，存储的内容是基于key-value的键值对映射，一个映射不能有重复的
键，一个键最多只能映射一个值。
#### （1） 元素特性
HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只
能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Co
mparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判
断，则key不可以为null，反之亦然。
#### （2）顺序特性
HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的
值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节
点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的
情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Com
parator接口实现排序方式。
#### （3）初始化与增长方式
初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一
定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。
扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。
#### （4）线程安全性
HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数
据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现
非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进
入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作
也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。
HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据
的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使用Co
ncurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lo
ck实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分
配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访
问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有
长足的提升。
#### (5)一段话HashMap
HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用
键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对
象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表
来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个
链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个
bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈
值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。
